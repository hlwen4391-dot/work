# 2025-12-23 修复记录

## 修复 1：cc.Action 弃用警告

### 问题
```
⚠️ cc.Action is deprecated. please use cc.Tween instead
```

### 原因
在 `AttackMover.js` 中使用了 Cocos Creator 的旧 Action API：
- `cc.moveTo()`
- `cc.scaleTo()`
- `cc.sequence()`
- `cc.callFunc()`
- `cc.delayTime()`
- `node.runAction()`
- `node.stopAllActions()`

### 解决方案
将所有旧 Action API 改为新的 **cc.tween** API：

#### 修改前（旧 API）
```javascript
const seq = cc.sequence(
    cc.moveTo(duration, targetPos).easing(cc.easeInOut(2)),
    cc.callFunc(() => this._playAttackAnimation()),
    cc.delayTime(this.attackDuration),
    cc.moveTo(duration, originalPos),
    cc.callFunc(() => this._onSequenceComplete())
);
this.node.runAction(seq);
```

#### 修改后（新 API）
```javascript
cc.tween(this.node)
    .to(duration, { position: targetPos }, { easing: 'sineInOut' })
    .call(() => this._playAttackAnimation())
    .delay(this.attackDuration)
    .to(duration, { position: originalPos }, { easing: 'sineInOut' })
    .call(() => this._onSequenceComplete())
    .start();
```

### API 对照表

| 旧 API (Action) | 新 API (Tween) | 说明 |
|----------------|----------------|------|
| `cc.moveTo(duration, pos)` | `cc.tween(node).to(duration, { position: pos })` | 移动到位置 |
| `cc.scaleTo(duration, scale)` | `cc.tween(node).to(duration, { scale: scale })` | 缩放 |
| `cc.sequence(...)` | `cc.tween(node).to(...).to(...)` | 序列动画 |
| `cc.callFunc(callback)` | `.call(callback)` | 回调函数 |
| `cc.delayTime(duration)` | `.delay(duration)` | 延迟 |
| `node.runAction(action)` | `.start()` | 开始执行 |
| `node.stopAllActions()` | `cc.Tween.stopAllByTarget(node)` | 停止所有动画 |
| `action.easing(cc.easeInOut(2))` | `{ easing: 'sineInOut' }` | 缓动函数 |

### 缓动函数对照

| 旧缓动 | 新缓动字符串 |
|--------|-------------|
| `cc.easeIn(2)` | `'sineIn'` |
| `cc.easeOut(2)` | `'sineOut'` |
| `cc.easeInOut(2)` | `'sineInOut'` |
| `cc.easeCubicActionIn()` | `'cubicIn'` |
| `cc.easeCubicActionOut()` | `'cubicOut'` |

---

## 修复 2：预制体 Scale 错误

### 问题
预制体的 `scale` 值不正确，导致单位显示异常。

### 原因
1. 预制体在 Cocos Creator 编辑器中的初始 scale 不是 1
2. 动画执行后 scale 没有正确重置
3. 父子节点的 scale 相互影响

### 解决方案

#### 方案 A：在代码中自动修复（已实现）
```javascript
onLoad() {
    // 确保节点初始 scale 为 1
    if (this.node.scale !== 1) {
        cc.warn(`${this.node.name} 的初始 scale 不是 1，已重置为 1`);
        this.node.scale = 1.0;
    }
}
```

#### 方案 B：在编辑器中手动修复（推荐）
1. 在 Cocos Creator 中打开 `Hero.prefab` 和 `Monster.prefab`
2. 选择**根节点**
3. 在属性检查器中找到 `Node` 组件
4. 将 `Scale` 设置为：
   - X: `1`
   - Y: `1`
   - Z: `1` (如果是 3D)
5. 保存预制件（Ctrl+S）

#### 方案 C：批量检查和修复
在 `BattleController.js` 的 `spawnUnits()` 方法中添加：

```javascript
spawnUnits() {
    // ... 原有代码
    
    for (let data of heroData) {
        let node = cc.instantiate(this.heroPrefab);
        
        // 确保 scale 正确
        if (node.scale !== 1) {
            cc.warn(`${node.name} scale 不正确: ${node.scale}，已重置为 1`);
            node.scale = 1.0;
        }
        
        node.parent = this.heroParent;
        this.initEntity(node, data, "hero");
        this.heros.push(node);
    }
}
```

---

## 修复 3：动画结束后 Scale 重置

确保动画结束后 scale 恢复到 1：

```javascript
_playAttackAnimation() {
    cc.tween(this.node)
        .to(this.attackDuration * 0.3, { scale: 1.2 })
        .to(this.attackDuration * 0.7, { scale: 1.0 })  // ✅ 明确恢复到 1.0
        .start();
}

stopAttack() {
    cc.Tween.stopAllByTarget(this.node);
    this.node.scale = 1.0;  // ✅ 强制重置为 1.0
    // ...
}
```

---

## 测试检查清单

运行场景后检查以下内容：

- [ ] ✅ 控制台没有 `cc.Action is deprecated` 警告
- [ ] ✅ 攻击动画正常播放（移动 → 攻击 → 返回）
- [ ] ✅ 单位的 scale 始终保持在 1.0
- [ ] ✅ 动画结束后单位位置和大小正确
- [ ] ✅ 战斗结束后没有堆栈溢出错误

---

## 相关文件

- **修改的文件**：
  - `BattleGame/assets/Scripts/ecs/AttackMover.js`

- **需要检查的预制件**：
  - `BattleGame/assets/Prefabs/Hero.prefab`
  - `BattleGame/assets/Prefabs/Monster.prefab`

---

## 如果还有 Scale 问题

### 调试方法 1：在控制台打印 scale
```javascript
onLoad() {
    cc.log(`${this.node.name} 初始 scale: ${this.node.scale}`);
    cc.log(`父节点 scale: ${this.node.parent.scale}`);
}
```

### 调试方法 2：检查父节点
```javascript
// 在 BattleController.js 中
spawnUnits() {
    cc.log(`heroParent scale: ${this.heroParent.scale}`);
    cc.log(`monsterParent scale: ${this.monsterParent.scale}`);
}
```

### 调试方法 3：检查预制件层级
打开预制件，确保：
1. 根节点的 scale 是 (1, 1, 1)
2. 所有子节点的 scale 也是 (1, 1, 1)
3. 没有嵌套的多层节点导致 scale 累积

---

**修复日期**: 2025-12-23  
**修复文件**: `AttackMover.js`  
**修复内容**: 旧 Action API → 新 Tween API，Scale 自动修复

